# 07-redis

### 1.使用Redis有哪些好处？

​	1）速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)
​	2）支持丰富数据类型，支持string，list，set，sorted set，hash
​	3）支持事务，操作都是原子性的，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行
​	4）丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除
​	5）支持持久化，支持数据主从备份，数据恢复

### 2.Redis相比memcached有哪些优势？

​	1）memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型
​	2）redis的速度比memcached快很多
​	3）redis可以持久化其数据
​	4）Redis支持数据的备份，即master-slave模式的数据备份。
​	5）使用底层模型不同
​		它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。
​		Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。
​	6）value大小：redis最大可以达到1GB，而memcache只有1MB

### 3.redi能用来做什么：

​	String：缓存、分布式锁、分布式session共享、分布式计数器：限流、统计登录人数
​	list:共同好友交集、实现队列和栈
​	set:点赞数
​	zsort:分数排行榜、
​	geo:经纬度范围

### 4.redis为什么那么快?

​	资料：https://blog.csdn.net/chenyao1994/article/details/79491337
​	1）完全基于内存：绝大部分请求是纯粹的内存操作，非常快速。
​	2）数据结构简单：对数据操作也简单，Redis中的数据结构是专门进行设计的；
​	3）采用单线程：避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用考虑死锁；
​	4）多路I/O复用模型：非阻塞IO，epoll 是只轮询那些真正发出了io事件的流；这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。
​	5）使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；

### 5.Redis为什么是单线程的？

​	因为CPU不是Redis的瓶颈。Redis的瓶颈最有可能是机器内存或者网络带宽。线程安全。
​	如果万一CPU成为你的Redis瓶颈了那怎么办？
​		多启动几个Redis进程就好了，集群

### 6.Redis缓存穿透，缓存击穿，缓存雪崩 

​	资料：https://www.cnblogs.com/xichji/p/11286443.html

> **缓存穿透：**根据key查到值不存在，从数据库拿数据，数据库数据本身不存在，则不写入缓存。这样导致每次请求都要从数据库查
> ​	解决方式：存入一个默认值（空结果也可以）

> **缓存击穿：**在高并发情况下，正好某个缓存失效了，批量去数据库拿，以及回存在缓存，这些并发压力瞬间落在了数据库上。
> 	写缓存加锁，队列控制写线程数量：缓存失效，获取到值为空的时候不是立马去load db，而是先获取锁。获取不到锁就再调get();

> **缓存雪崩：**在高并发情况下，大量的缓存同一时间失效，所有的查询都落在数据库上，压垮数据库，造成了缓存雪崩。
> 解决方式：
> 	1）写缓存加锁，队列控制数量：在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。
> 	2）存缓存时间：缓存过期时间尽量分散。

### 7.redis的过期策略以及内存淘汰机制

​	资料：https://blog.csdn.net/ylp_boy/article/details/51494606
​	**过期策略**：定期删除 + 惰性删除 + 定时删除
​		定期删除：redis默认每个100ms检查一次，而随机抽取一批进行检查，过期的进行删除；	
​		惰性删除：大部分redis过期没有被主动删除，那在线程去取内存的时候会去检查，进行过期数据删除。	优缺点：对cpu友好，对内存不友好。
​		定时删除：在设置键的过期时间的同时，创建一个定时器（timer），让定时器在键的过期时间来临时，立即执行对键的删除操作。	优缺点：对内存友好，对cpu不友好。

​	**淘汰策略**
​		volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
​		volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
​		volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
​		allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰
​		allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
​		no-enviction（驱逐）（默认）：禁止驱逐数据，新写入操作会报错

### 8.redis分片会有什么问题？

​	1）集合操作：涉及多个键的操作通常不支持，如集合求交集
​	2）事务处理：涉及多个键的事务不能使用，（存在通信故障问题）
​	3）数据备份：当使用了分片，数据备份处理变得更复杂，例如，你需要处理多个 RDB/AOF 文件，备份数据时你需要聚合多个实例和主机的持久化文件
​	4）分片扩容：添加和删除容量也很复杂，扩容删除都要进行数据重新分布
​	5）分片宕机：部分节点挂了之后，那些分片会不可用

### 9.redis的底层数据结构

​	资料：https://www.cnblogs.com/doit8791/p/8563667.html
​		https://www.cnblogs.com/gaopengfirst/p/10062980.html
​		https://www.cnblogs.com/ysocean/p/9080942.html
​		https://www.cnblogs.com/ysocean/p/9102811.html
​	Redis内部使用一个 redisObject 对象来表示所有的 key 和 value。每次在Redis数据库中创建一个键值对时，至少会创建两个对象，一个是键对象，一个是值对象。
​	redis总的有String、list、set、zset、hash，底层是通过SDS（简单动态字符串）、双端双向链表、hash表、跳跃表、整数集合、压缩列表等数据结构实现的。

> **SDS**：用于存放字符串，redis自己构建的一种数据类型。
> ​		结构：
> ​			1.buf[] byte数组用来保存字符串的每个字节；
> ​			2.len 保存了SDS保存字符串的长度；
> ​			3.free 记录了 buf 数组中未使用的字节数量。
> ​		优点：
> ​			1.字符串长度获取复杂度为O(1)；
> ​			2.减少修改字符串时的内存重新分配次数：1.空间预分配；2.空间惰性释放，对优化友好；
> ​			3.杜绝缓冲区溢出：底层使用的是C语言，数据过长，然后申请不到空间的话会缓冲区溢出；
>
> **双端链表**：
> 	结构：链表对象，保存head节点、tail节点、链长lenth，每个节点都关联next、previous节点。
> 	优点：
> 		1.链表长度获取复杂度为O(1)
> 		2.链表具有前置节点和后置节点的引用，获取这两个节点时间复杂度都为O(1)。可以利用实现栈、队列。
>
> **hash表**：
> 	结构：数组+链表，主链上是数组，数组每个位置上存放的是一个链表。结构和hashMap底层的hashTable是一样的。
> 	优点（功能优化）：
> 		1.扩容和收缩：当哈希表保存的键值对太多或者太少时，就要通过 rerehash(重新散列）来对哈希表进行相应的扩展或者收缩。扩容容量是2的幂次方运算，当达到负载因子是进行扩容。
> 		2.渐近式 rehash：当hash表里面的数据量很大时候，为防止长时间停顿，rehash时数据操作可能会在两个哈希表上进行，新hash表上没找到去找旧hash表，但写入肯定是在新的hash表上进行。
>
> **跳跃表：**一个多层索引结构的链表。
> 	结构：
> 		1.从数据链表里往上一层层的提取出索引，用单链表结构存储；
> 		2.每层元素都按score从小到大排序，下面层链表含有上面层链表的所有元素；
> 		3.最底层链表含有全量元素。
> 		4.查找、插入、删除都是从上层往下逐层定位。
> 	优点：
> 		1.通过多层索引的方式来提高查找效率；
> 	缺点：
> 		1.会额外的占用空间。通过牺牲空间换时间。
>
> **整数集合**：用于保存整数值的集合抽象数据类型，方便整数型数据操作（如自增、自减）。
>
> **压缩列表：**是Redis为了节省内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型数据结构，一个压缩列表可以包含任意多个节点（entry），每个节点可以保存一个字节数组或者一个整数值。




### 10.redis哨兵模式原理

​	资料：https://www.cnblogs.com/gunduzi/p/13160448.html
​		https://blog.csdn.net/macro_g/article/details/82593996
​	哨兵模式：哨兵模式是一个能自动监控集群状态的一个部署模式。哨兵是独立运行的进程，其原理是通过发送命令，等待redis服务器响应的方式去监控集群中各个节点的状态，主挂了可以自动选主。解决传统主从模式中主库挂了必须人工恢复的问题。

> 哨兵集群中的每个节点都会启动三个定时任务：
> ​		第一个定时任务（心跳检测，监控）： 每个sentinel节点每隔1s向所有的master、slaver、别的sentinel节点发送一个PING命令，作用：心跳检测（检测各节点存活状态）
> ​		第二个定时任务（信息交换，提醒）： 每个sentinel节点每隔2s都会向master的__sentinel__:hello这个channel（频道）中发送自己掌握的集群信息和自己的一些信息（比如host,ip,run id），这个是利用redis的pub/sub功能，每个sentinel节点都会订阅这个channel，也就是说，每个sentinel节点都可以知道别的sentinel节点掌握的集群信息，作用：信息交换，了解别的sentinel的信息和他们对于主节点的判断
> ​		第三个定时任务（拓扑更新，自动故障迁移）： 每个sentinel节点每隔10s都会向master和slaver发送INFO命令，作用：发现最新的集群拓扑结构（变更后会推送给客户端）

> 选主：
> 	哨兵对master心跳检测失败一点时间后会认为master下线，就是说的主观下线；
> 	哨兵主观下线数>配置主观下线数，那么会标记master为客观下线，然后利用基于ratf协议实现的投票机制投票选主，保证最后选主的一致性。
> 	后续工作：恢复数据，拓扑更新，改slave的slaveof信息。...