(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{260:function(t,e,s){"use strict";s.r(e);var n=s(28),r=Object(n.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"_07-redis"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_07-redis"}},[t._v("#")]),t._v(" 07-redis")]),t._v(" "),s("h3",{attrs:{id:"_1-使用redis有哪些好处？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-使用redis有哪些好处？"}},[t._v("#")]),t._v(" 1.使用Redis有哪些好处？")]),t._v(" "),s("p",[t._v("​\t1）速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)\n​\t2）支持丰富数据类型，支持string，list，set，sorted set，hash\n​\t3）支持事务，操作都是原子性的，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行\n​\t4）丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除\n​\t5）支持持久化，支持数据主从备份，数据恢复")]),t._v(" "),s("h3",{attrs:{id:"_2-redis相比memcached有哪些优势？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-redis相比memcached有哪些优势？"}},[t._v("#")]),t._v(" 2.Redis相比memcached有哪些优势？")]),t._v(" "),s("p",[t._v("​\t1）memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型\n​\t2）redis的速度比memcached快很多\n​\t3）redis可以持久化其数据\n​\t4）Redis支持数据的备份，即master-slave模式的数据备份。\n​\t5）使用底层模型不同\n​\t\t它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。\n​\t\tRedis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。\n​\t6）value大小：redis最大可以达到1GB，而memcache只有1MB")]),t._v(" "),s("h3",{attrs:{id:"_3-redi能用来做什么："}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-redi能用来做什么："}},[t._v("#")]),t._v(" 3.redi能用来做什么：")]),t._v(" "),s("p",[t._v("​\tString：缓存、分布式锁、分布式session共享、分布式计数器：限流、统计登录人数\n​\tlist:共同好友交集、实现队列和栈\n​\tset:点赞数\n​\tzsort:分数排行榜、\n​\tgeo:经纬度范围")]),t._v(" "),s("h3",{attrs:{id:"_4-redis为什么那么快"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-redis为什么那么快"}},[t._v("#")]),t._v(" 4.redis为什么那么快?")]),t._v(" "),s("p",[t._v("​\t资料：https://blog.csdn.net/chenyao1994/article/details/79491337\n​\t1）完全基于内存：绝大部分请求是纯粹的内存操作，非常快速。\n​\t2）数据结构简单：对数据操作也简单，Redis中的数据结构是专门进行设计的；\n​\t3）采用单线程：避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用考虑死锁；\n​\t4）多路I/O复用模型：非阻塞IO，epoll 是只轮询那些真正发出了io事件的流；这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。\n​\t5）使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；")]),t._v(" "),s("h3",{attrs:{id:"_5-redis为什么是单线程的？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-redis为什么是单线程的？"}},[t._v("#")]),t._v(" 5.Redis为什么是单线程的？")]),t._v(" "),s("p",[t._v("​\t因为CPU不是Redis的瓶颈。Redis的瓶颈最有可能是机器内存或者网络带宽。线程安全。\n​\t如果万一CPU成为你的Redis瓶颈了那怎么办？\n​\t\t多启动几个Redis进程就好了，集群")]),t._v(" "),s("h3",{attrs:{id:"_6-redis缓存穿透，缓存击穿，缓存雪崩"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-redis缓存穿透，缓存击穿，缓存雪崩"}},[t._v("#")]),t._v(" 6.Redis缓存穿透，缓存击穿，缓存雪崩")]),t._v(" "),s("p",[t._v("​\t资料：https://www.cnblogs.com/xichji/p/11286443.html")]),t._v(" "),s("blockquote",[s("p",[t._v("**缓存穿透：**根据key查到值不存在，从数据库拿数据，数据库数据本身不存在，则不写入缓存。这样导致每次请求都要从数据库查\n​\t解决方式：存入一个默认值（空结果也可以）")])]),t._v(" "),s("blockquote",[s("p",[t._v("**缓存击穿：**在高并发情况下，正好某个缓存失效了，批量去数据库拿，以及回存在缓存，这些并发压力瞬间落在了数据库上。\n写缓存加锁，队列控制写线程数量：缓存失效，获取到值为空的时候不是立马去load db，而是先获取锁。获取不到锁就再调get();")])]),t._v(" "),s("blockquote",[s("p",[t._v("**缓存雪崩：**在高并发情况下，大量的缓存同一时间失效，所有的查询都落在数据库上，压垮数据库，造成了缓存雪崩。\n解决方式：\n1）写缓存加锁，队列控制数量：在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。\n2）存缓存时间：缓存过期时间尽量分散。")])]),t._v(" "),s("h3",{attrs:{id:"_7-redis的过期策略以及内存淘汰机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-redis的过期策略以及内存淘汰机制"}},[t._v("#")]),t._v(" 7.redis的过期策略以及内存淘汰机制")]),t._v(" "),s("p",[t._v("​\t资料：https://blog.csdn.net/ylp_boy/article/details/51494606\n​\t"),s("strong",[t._v("过期策略")]),t._v("：定期删除 + 惰性删除 + 定时删除\n​\t\t定期删除：redis默认每个100ms检查一次，而随机抽取一批进行检查，过期的进行删除；\t\n​\t\t惰性删除：大部分redis过期没有被主动删除，那在线程去取内存的时候会去检查，进行过期数据删除。\t优缺点：对cpu友好，对内存不友好。\n​\t\t定时删除：在设置键的过期时间的同时，创建一个定时器（timer），让定时器在键的过期时间来临时，立即执行对键的删除操作。\t优缺点：对内存友好，对cpu不友好。")]),t._v(" "),s("p",[t._v("​\t"),s("strong",[t._v("淘汰策略")]),t._v("\n​\t\tvolatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰\n​\t\tvolatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰\n​\t\tvolatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰\n​\t\tallkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰\n​\t\tallkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰\n​\t\tno-enviction（驱逐）（默认）：禁止驱逐数据，新写入操作会报错")]),t._v(" "),s("h3",{attrs:{id:"_8-redis分片会有什么问题？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-redis分片会有什么问题？"}},[t._v("#")]),t._v(" 8.redis分片会有什么问题？")]),t._v(" "),s("p",[t._v("​\t1）集合操作：涉及多个键的操作通常不支持，如集合求交集\n​\t2）事务处理：涉及多个键的事务不能使用，（存在通信故障问题）\n​\t3）数据备份：当使用了分片，数据备份处理变得更复杂，例如，你需要处理多个 RDB/AOF 文件，备份数据时你需要聚合多个实例和主机的持久化文件\n​\t4）分片扩容：添加和删除容量也很复杂，扩容删除都要进行数据重新分布\n​\t5）分片宕机：部分节点挂了之后，那些分片会不可用")]),t._v(" "),s("h3",{attrs:{id:"_9-redis的底层数据结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9-redis的底层数据结构"}},[t._v("#")]),t._v(" 9.redis的底层数据结构")]),t._v(" "),s("p",[t._v("​\t资料：https://www.cnblogs.com/doit8791/p/8563667.html\n​\t\thttps://www.cnblogs.com/gaopengfirst/p/10062980.html\n​\t\thttps://www.cnblogs.com/ysocean/p/9080942.html\n​\t\thttps://www.cnblogs.com/ysocean/p/9102811.html\n​\tRedis内部使用一个 redisObject 对象来表示所有的 key 和 value。每次在Redis数据库中创建一个键值对时，至少会创建两个对象，一个是键对象，一个是值对象。\n​\tredis总的有String、list、set、zset、hash，底层是通过SDS（简单动态字符串）、双端双向链表、hash表、跳跃表、整数集合、压缩列表等数据结构实现的。")]),t._v(" "),s("blockquote",[s("p",[s("strong",[t._v("SDS")]),t._v("：用于存放字符串，redis自己构建的一种数据类型。\n​\t\t结构：\n​\t\t\t1.buf[] byte数组用来保存字符串的每个字节；\n​\t\t\t2.len 保存了SDS保存字符串的长度；\n​\t\t\t3.free 记录了 buf 数组中未使用的字节数量。\n​\t\t优点：\n​\t\t\t1.字符串长度获取复杂度为O(1)；\n​\t\t\t2.减少修改字符串时的内存重新分配次数：1.空间预分配；2.空间惰性释放，对优化友好；\n​\t\t\t3.杜绝缓冲区溢出：底层使用的是C语言，数据过长，然后申请不到空间的话会缓冲区溢出；")]),t._v(" "),s("p",[s("strong",[t._v("双端链表")]),t._v("：\n结构：链表对象，保存head节点、tail节点、链长lenth，每个节点都关联next、previous节点。\n优点：\n1.链表长度获取复杂度为O(1)\n2.链表具有前置节点和后置节点的引用，获取这两个节点时间复杂度都为O(1)。可以利用实现栈、队列。")]),t._v(" "),s("p",[s("strong",[t._v("hash表")]),t._v("：\n结构：数组+链表，主链上是数组，数组每个位置上存放的是一个链表。结构和hashMap底层的hashTable是一样的。\n优点（功能优化）：\n1.扩容和收缩：当哈希表保存的键值对太多或者太少时，就要通过 rerehash(重新散列）来对哈希表进行相应的扩展或者收缩。扩容容量是2的幂次方运算，当达到负载因子是进行扩容。\n2.渐近式 rehash：当hash表里面的数据量很大时候，为防止长时间停顿，rehash时数据操作可能会在两个哈希表上进行，新hash表上没找到去找旧hash表，但写入肯定是在新的hash表上进行。")]),t._v(" "),s("p",[t._v("**跳跃表：**一个多层索引结构的链表。\n结构：\n1.从数据链表里往上一层层的提取出索引，用单链表结构存储；\n2.每层元素都按score从小到大排序，下面层链表含有上面层链表的所有元素；\n3.最底层链表含有全量元素。\n4.查找、插入、删除都是从上层往下逐层定位。\n优点：\n1.通过多层索引的方式来提高查找效率；\n缺点：\n1.会额外的占用空间。通过牺牲空间换时间。")]),t._v(" "),s("p",[s("strong",[t._v("整数集合")]),t._v("：用于保存整数值的集合抽象数据类型，方便整数型数据操作（如自增、自减）。")]),t._v(" "),s("p",[t._v("**压缩列表：**是Redis为了节省内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型数据结构，一个压缩列表可以包含任意多个节点（entry），每个节点可以保存一个字节数组或者一个整数值。")])]),t._v(" "),s("h3",{attrs:{id:"_10-redis哨兵模式原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_10-redis哨兵模式原理"}},[t._v("#")]),t._v(" 10.redis哨兵模式原理")]),t._v(" "),s("p",[t._v("​\t资料：https://www.cnblogs.com/gunduzi/p/13160448.html\n​\t\thttps://blog.csdn.net/macro_g/article/details/82593996\n​\t哨兵模式：哨兵模式是一个能自动监控集群状态的一个部署模式。哨兵是独立运行的进程，其原理是通过发送命令，等待redis服务器响应的方式去监控集群中各个节点的状态，主挂了可以自动选主。解决传统主从模式中主库挂了必须人工恢复的问题。")]),t._v(" "),s("blockquote",[s("p",[t._v("哨兵集群中的每个节点都会启动三个定时任务：\n​\t\t第一个定时任务（心跳检测，监控）： 每个sentinel节点每隔1s向所有的master、slaver、别的sentinel节点发送一个PING命令，作用：心跳检测（检测各节点存活状态）\n​\t\t第二个定时任务（信息交换，提醒）： 每个sentinel节点每隔2s都会向master的__sentinel__:hello这个channel（频道）中发送自己掌握的集群信息和自己的一些信息（比如host,ip,run id），这个是利用redis的pub/sub功能，每个sentinel节点都会订阅这个channel，也就是说，每个sentinel节点都可以知道别的sentinel节点掌握的集群信息，作用：信息交换，了解别的sentinel的信息和他们对于主节点的判断\n​\t\t第三个定时任务（拓扑更新，自动故障迁移）： 每个sentinel节点每隔10s都会向master和slaver发送INFO命令，作用：发现最新的集群拓扑结构（变更后会推送给客户端）")])]),t._v(" "),s("blockquote",[s("p",[t._v("选主：\n哨兵对master心跳检测失败一点时间后会认为master下线，就是说的主观下线；\n哨兵主观下线数>配置主观下线数，那么会标记master为客观下线，然后利用基于ratf协议实现的投票机制投票选主，保证最后选主的一致性。\n后续工作：恢复数据，拓扑更新，改slave的slaveof信息。...")])])])}),[],!1,null,null,null);e.default=r.exports}}]);