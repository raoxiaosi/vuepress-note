<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>07-redis | 槲寄生</title>
    <meta name="description" content="欢迎来到我的个人空间">
    <meta name="generator" content="VuePress 1.4.0">
    <link rel="icon" href="/vuepress/logo.png">
  <link rel="stylesheet" href="/vuepress/layui/css/layui.css">
  <link rel="stylesheet" href="/vuepress/css/common.css">
  <script charset="utf-8" src="/vuepress/js/jquery-3.2.1.min.js"></script>
  <script charset="utf-8" src="/vuepress/layui/layui.js"></script>
  <script charset="utf-8" src="/vuepress/layui/layui.all.js"></script>
  <script charset="utf-8" src="/vuepress/js/common.js"></script>
    
    <link rel="preload" href="/vuepress/assets/css/0.styles.bf358951.css" as="style"><link rel="preload" href="/vuepress/assets/js/app.0ab85dbf.js" as="script"><link rel="preload" href="/vuepress/assets/js/2.fa597f1f.js" as="script"><link rel="preload" href="/vuepress/assets/js/15.7511402d.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/10.f6e24221.js"><link rel="prefetch" href="/vuepress/assets/js/11.9b53f862.js"><link rel="prefetch" href="/vuepress/assets/js/12.0c15f9b3.js"><link rel="prefetch" href="/vuepress/assets/js/13.c42576a8.js"><link rel="prefetch" href="/vuepress/assets/js/14.7fe4157c.js"><link rel="prefetch" href="/vuepress/assets/js/16.a91d5d90.js"><link rel="prefetch" href="/vuepress/assets/js/17.8376b68f.js"><link rel="prefetch" href="/vuepress/assets/js/18.8ff81022.js"><link rel="prefetch" href="/vuepress/assets/js/19.e5f477d5.js"><link rel="prefetch" href="/vuepress/assets/js/20.5bb2e4e8.js"><link rel="prefetch" href="/vuepress/assets/js/21.d074e25d.js"><link rel="prefetch" href="/vuepress/assets/js/22.d534d55b.js"><link rel="prefetch" href="/vuepress/assets/js/23.87197592.js"><link rel="prefetch" href="/vuepress/assets/js/24.9c0c7001.js"><link rel="prefetch" href="/vuepress/assets/js/25.f96c3693.js"><link rel="prefetch" href="/vuepress/assets/js/26.fb33c535.js"><link rel="prefetch" href="/vuepress/assets/js/27.d9fee795.js"><link rel="prefetch" href="/vuepress/assets/js/28.5301b223.js"><link rel="prefetch" href="/vuepress/assets/js/29.d300dd73.js"><link rel="prefetch" href="/vuepress/assets/js/3.a40ce906.js"><link rel="prefetch" href="/vuepress/assets/js/30.d2a2c3fb.js"><link rel="prefetch" href="/vuepress/assets/js/31.f01434dc.js"><link rel="prefetch" href="/vuepress/assets/js/32.19be5ee2.js"><link rel="prefetch" href="/vuepress/assets/js/4.cd6dc910.js"><link rel="prefetch" href="/vuepress/assets/js/5.ce653b99.js"><link rel="prefetch" href="/vuepress/assets/js/6.efc95009.js"><link rel="prefetch" href="/vuepress/assets/js/7.21143678.js"><link rel="prefetch" href="/vuepress/assets/js/8.6e7ad8ff.js"><link rel="prefetch" href="/vuepress/assets/js/9.cd05ea08.js">
    <link rel="stylesheet" href="/vuepress/assets/css/0.styles.bf358951.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vuepress/" class="home-link router-link-active"><img src="/vuepress/logo.png" alt="槲寄生" class="logo"> <span class="site-name can-hide">槲寄生</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/vuepress/java/" class="nav-link">
  java
</a></div><div class="nav-item"><a href="/vuepress/interview/" class="nav-link router-link-active">
  面试题
</a></div><div class="nav-item"><a href="/vuepress/middleware/" class="nav-link">
  中间件
</a></div><div class="nav-item"><a href="/vuepress/devops/" class="nav-link">
  运维相关
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/vuepress/java/" class="nav-link">
  java
</a></div><div class="nav-item"><a href="/vuepress/interview/" class="nav-link router-link-active">
  面试题
</a></div><div class="nav-item"><a href="/vuepress/middleware/" class="nav-link">
  中间件
</a></div><div class="nav-item"><a href="/vuepress/devops/" class="nav-link">
  运维相关
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>java</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vuepress/interview/docs/java/01-java基础.html" class="sidebar-link">01-java基础</a></li><li><a href="/vuepress/interview/docs/java/02-java高级.html" class="sidebar-link">02-java高级</a></li><li><a href="/vuepress/interview/docs/java/03-数据结构算法.html" class="sidebar-link">03-数据结构算法</a></li><li><a href="/vuepress/interview/docs/java/04-数据库.html" class="sidebar-link">04-数据库</a></li><li><a href="/vuepress/interview/docs/java/05-分布式架构.html" class="sidebar-link">05-分布式架构</a></li><li><a href="/vuepress/interview/docs/java/06-开发协作.html" class="sidebar-link">06-开发协作</a></li><li><a href="/vuepress/interview/docs/java/07-redis.html" class="active sidebar-link">07-redis</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vuepress/interview/docs/java/08-spring.html" class="sidebar-link">08-spring</a></li><li><a href="/vuepress/interview/docs/java/09-mybatis.html" class="sidebar-link">09-mybatis</a></li><li><a href="/vuepress/interview/docs/java/10-dubbo.html" class="sidebar-link">10-dubbo</a></li><li><a href="/vuepress/interview/docs/java/11-springboot.html" class="sidebar-link">11-springboot</a></li><li><a href="/vuepress/interview/docs/java/12-springcloud.html" class="sidebar-link">12-springcloud</a></li><li><a href="/vuepress/interview/docs/java/13-Struts、hibernate.html" class="sidebar-link">13-Struts、hibernate</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="_07-redis"><a href="#_07-redis" class="header-anchor">#</a> 07-redis</h1> <h3 id="_1-使用redis有哪些好处？"><a href="#_1-使用redis有哪些好处？" class="header-anchor">#</a> 1.使用Redis有哪些好处？</h3> <p>​	1）速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)
​	2）支持丰富数据类型，支持string，list，set，sorted set，hash
​	3）支持事务，操作都是原子性的，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行
​	4）丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除
​	5）支持持久化，支持数据主从备份，数据恢复</p> <h3 id="_2-redis相比memcached有哪些优势？"><a href="#_2-redis相比memcached有哪些优势？" class="header-anchor">#</a> 2.Redis相比memcached有哪些优势？</h3> <p>​	1）memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型
​	2）redis的速度比memcached快很多
​	3）redis可以持久化其数据
​	4）Redis支持数据的备份，即master-slave模式的数据备份。
​	5）使用底层模型不同
​		它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。
​		Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。
​	6）value大小：redis最大可以达到1GB，而memcache只有1MB</p> <h3 id="_3-redi能用来做什么："><a href="#_3-redi能用来做什么：" class="header-anchor">#</a> 3.redi能用来做什么：</h3> <p>​	String：缓存、分布式锁、分布式session共享、分布式计数器：限流、统计登录人数
​	list:共同好友交集、实现队列和栈
​	set:点赞数
​	zsort:分数排行榜、
​	geo:经纬度范围</p> <h3 id="_4-redis为什么那么快"><a href="#_4-redis为什么那么快" class="header-anchor">#</a> 4.redis为什么那么快?</h3> <p>​	资料：https://blog.csdn.net/chenyao1994/article/details/79491337
​	1）完全基于内存：绝大部分请求是纯粹的内存操作，非常快速。
​	2）数据结构简单：对数据操作也简单，Redis中的数据结构是专门进行设计的；
​	3）采用单线程：避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用考虑死锁；
​	4）多路I/O复用模型：非阻塞IO，epoll 是只轮询那些真正发出了io事件的流；这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。
​	5）使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；</p> <h3 id="_5-redis为什么是单线程的？"><a href="#_5-redis为什么是单线程的？" class="header-anchor">#</a> 5.Redis为什么是单线程的？</h3> <p>​	因为CPU不是Redis的瓶颈。Redis的瓶颈最有可能是机器内存或者网络带宽。线程安全。
​	如果万一CPU成为你的Redis瓶颈了那怎么办？
​		多启动几个Redis进程就好了，集群</p> <h3 id="_6-redis缓存穿透，缓存击穿，缓存雪崩"><a href="#_6-redis缓存穿透，缓存击穿，缓存雪崩" class="header-anchor">#</a> 6.Redis缓存穿透，缓存击穿，缓存雪崩</h3> <p>​	资料：https://www.cnblogs.com/xichji/p/11286443.html</p> <blockquote><p>**缓存穿透：**根据key查到值不存在，从数据库拿数据，数据库数据本身不存在，则不写入缓存。这样导致每次请求都要从数据库查
​	解决方式：存入一个默认值（空结果也可以）</p></blockquote> <blockquote><p>**缓存击穿：**在高并发情况下，正好某个缓存失效了，批量去数据库拿，以及回存在缓存，这些并发压力瞬间落在了数据库上。
写缓存加锁，队列控制写线程数量：缓存失效，获取到值为空的时候不是立马去load db，而是先获取锁。获取不到锁就再调get();</p></blockquote> <blockquote><p>**缓存雪崩：**在高并发情况下，大量的缓存同一时间失效，所有的查询都落在数据库上，压垮数据库，造成了缓存雪崩。
解决方式：
1）写缓存加锁，队列控制数量：在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。
2）存缓存时间：缓存过期时间尽量分散。</p></blockquote> <h3 id="_7-redis的过期策略以及内存淘汰机制"><a href="#_7-redis的过期策略以及内存淘汰机制" class="header-anchor">#</a> 7.redis的过期策略以及内存淘汰机制</h3> <p>​	资料：https://blog.csdn.net/ylp_boy/article/details/51494606
​	<strong>过期策略</strong>：定期删除 + 惰性删除 + 定时删除
​		定期删除：redis默认每个100ms检查一次，而随机抽取一批进行检查，过期的进行删除；	
​		惰性删除：大部分redis过期没有被主动删除，那在线程去取内存的时候会去检查，进行过期数据删除。	优缺点：对cpu友好，对内存不友好。
​		定时删除：在设置键的过期时间的同时，创建一个定时器（timer），让定时器在键的过期时间来临时，立即执行对键的删除操作。	优缺点：对内存友好，对cpu不友好。</p> <p>​	<strong>淘汰策略</strong>
​		volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
​		volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
​		volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
​		allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰
​		allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
​		no-enviction（驱逐）（默认）：禁止驱逐数据，新写入操作会报错</p> <h3 id="_8-redis分片会有什么问题？"><a href="#_8-redis分片会有什么问题？" class="header-anchor">#</a> 8.redis分片会有什么问题？</h3> <p>​	1）集合操作：涉及多个键的操作通常不支持，如集合求交集
​	2）事务处理：涉及多个键的事务不能使用，（存在通信故障问题）
​	3）数据备份：当使用了分片，数据备份处理变得更复杂，例如，你需要处理多个 RDB/AOF 文件，备份数据时你需要聚合多个实例和主机的持久化文件
​	4）分片扩容：添加和删除容量也很复杂，扩容删除都要进行数据重新分布
​	5）分片宕机：部分节点挂了之后，那些分片会不可用</p> <h3 id="_9-redis的底层数据结构"><a href="#_9-redis的底层数据结构" class="header-anchor">#</a> 9.redis的底层数据结构</h3> <p>​	资料：https://www.cnblogs.com/doit8791/p/8563667.html
​		https://www.cnblogs.com/gaopengfirst/p/10062980.html
​		https://www.cnblogs.com/ysocean/p/9080942.html
​		https://www.cnblogs.com/ysocean/p/9102811.html
​	Redis内部使用一个 redisObject 对象来表示所有的 key 和 value。每次在Redis数据库中创建一个键值对时，至少会创建两个对象，一个是键对象，一个是值对象。
​	redis总的有String、list、set、zset、hash，底层是通过SDS（简单动态字符串）、双端双向链表、hash表、跳跃表、整数集合、压缩列表等数据结构实现的。</p> <blockquote><p><strong>SDS</strong>：用于存放字符串，redis自己构建的一种数据类型。
​		结构：
​			1.buf[] byte数组用来保存字符串的每个字节；
​			2.len 保存了SDS保存字符串的长度；
​			3.free 记录了 buf 数组中未使用的字节数量。
​		优点：
​			1.字符串长度获取复杂度为O(1)；
​			2.减少修改字符串时的内存重新分配次数：1.空间预分配；2.空间惰性释放，对优化友好；
​			3.杜绝缓冲区溢出：底层使用的是C语言，数据过长，然后申请不到空间的话会缓冲区溢出；</p> <p><strong>双端链表</strong>：
结构：链表对象，保存head节点、tail节点、链长lenth，每个节点都关联next、previous节点。
优点：
1.链表长度获取复杂度为O(1)
2.链表具有前置节点和后置节点的引用，获取这两个节点时间复杂度都为O(1)。可以利用实现栈、队列。</p> <p><strong>hash表</strong>：
结构：数组+链表，主链上是数组，数组每个位置上存放的是一个链表。结构和hashMap底层的hashTable是一样的。
优点（功能优化）：
1.扩容和收缩：当哈希表保存的键值对太多或者太少时，就要通过 rerehash(重新散列）来对哈希表进行相应的扩展或者收缩。扩容容量是2的幂次方运算，当达到负载因子是进行扩容。
2.渐近式 rehash：当hash表里面的数据量很大时候，为防止长时间停顿，rehash时数据操作可能会在两个哈希表上进行，新hash表上没找到去找旧hash表，但写入肯定是在新的hash表上进行。</p> <p>**跳跃表：**一个多层索引结构的链表。
结构：
1.从数据链表里往上一层层的提取出索引，用单链表结构存储；
2.每层元素都按score从小到大排序，下面层链表含有上面层链表的所有元素；
3.最底层链表含有全量元素。
4.查找、插入、删除都是从上层往下逐层定位。
优点：
1.通过多层索引的方式来提高查找效率；
缺点：
1.会额外的占用空间。通过牺牲空间换时间。</p> <p><strong>整数集合</strong>：用于保存整数值的集合抽象数据类型，方便整数型数据操作（如自增、自减）。</p> <p>**压缩列表：**是Redis为了节省内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型数据结构，一个压缩列表可以包含任意多个节点（entry），每个节点可以保存一个字节数组或者一个整数值。</p></blockquote> <h3 id="_10-redis哨兵模式原理"><a href="#_10-redis哨兵模式原理" class="header-anchor">#</a> 10.redis哨兵模式原理</h3> <p>​	资料：https://www.cnblogs.com/gunduzi/p/13160448.html
​		https://blog.csdn.net/macro_g/article/details/82593996
​	哨兵模式：哨兵模式是一个能自动监控集群状态的一个部署模式。哨兵是独立运行的进程，其原理是通过发送命令，等待redis服务器响应的方式去监控集群中各个节点的状态，主挂了可以自动选主。解决传统主从模式中主库挂了必须人工恢复的问题。</p> <blockquote><p>哨兵集群中的每个节点都会启动三个定时任务：
​		第一个定时任务（心跳检测，监控）： 每个sentinel节点每隔1s向所有的master、slaver、别的sentinel节点发送一个PING命令，作用：心跳检测（检测各节点存活状态）
​		第二个定时任务（信息交换，提醒）： 每个sentinel节点每隔2s都会向master的__sentinel__:hello这个channel（频道）中发送自己掌握的集群信息和自己的一些信息（比如host,ip,run id），这个是利用redis的pub/sub功能，每个sentinel节点都会订阅这个channel，也就是说，每个sentinel节点都可以知道别的sentinel节点掌握的集群信息，作用：信息交换，了解别的sentinel的信息和他们对于主节点的判断
​		第三个定时任务（拓扑更新，自动故障迁移）： 每个sentinel节点每隔10s都会向master和slaver发送INFO命令，作用：发现最新的集群拓扑结构（变更后会推送给客户端）</p></blockquote> <blockquote><p>选主：
哨兵对master心跳检测失败一点时间后会认为master下线，就是说的主观下线；
哨兵主观下线数&gt;配置主观下线数，那么会标记master为客观下线，然后利用基于ratf协议实现的投票机制投票选主，保证最后选主的一致性。
后续工作：恢复数据，拓扑更新，改slave的slaveof信息。...</p></blockquote></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">9/19/2020, 2:47:39 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/vuepress/interview/docs/java/06-开发协作.html" class="prev">
        06-开发协作
      </a></span> <span class="next"><a href="/vuepress/interview/docs/java/08-spring.html">
        08-spring
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/vuepress/assets/js/app.0ab85dbf.js" defer></script><script src="/vuepress/assets/js/2.fa597f1f.js" defer></script><script src="/vuepress/assets/js/15.7511402d.js" defer></script>
  </body>
</html>
